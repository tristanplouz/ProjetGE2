	\chapter{Contrôle}
	Le système est contrôlé par deux microcontrôleurs un \pic ainsi qu'un \dspic. Le \pic se charge de la communication avec le smartphone au travers du module Bluetooth, il utilise ensuite les informations reçues pour contrôler le servomoteur de direction et envoie les informations adéquates au \dspic. Celui ci gère la puissance du moteur Brushless, il pilote l'onduleur triphasé présenté au paragraphe \ref{onduleur}.
		\section{Communication}
			\subsection{Vue d'ensemble}
				Dans notre système, nous disposons de plusieurs appareils \textit{intelligents}, le \pic , le \dspic et le smartphone, afin que l'on puisse profiter au maximum des capacités de chacun, ces éléments doivent communiquer entre eux.
				\subsubsection{Technologies utilisées}
				Nous utilisons des technologies de communication différentes entre chaque composant. Un résumé des communication est proposé figure \ref{com}.
				\paragraph{Entre le \textit{Smartphone} et le \textit{Module Bluetooth}} Une liaison \textit{Bluetooth Low Energy} est établie entre le module Bluetooth HC-05 et le smartphone. Dans notre cas, le téléphone est dit \textit{master} tandis que le module est dit \textit{slave}.
				\paragraph{Entre le \textit{Module Bluetooth} et le \textit{\pic} } Pour communiquer entre le module Bluetooth HC-05 et le \pic, une liaison série est utilisée. Cette liaison utilise deux conducteurs de données appelés TX et RX. La communication s'effectue à un \textit{baud rate}, une vitesse de transfert, commun entre les deux appareils. Le port TX d'un appareil est connecté au port RX du second et inversement.
				\paragraph{Entre le \textit{\dspic} et le \textit{\pic}} Entre ces deux composants, nous utilisons une connexion de type \textbf{SPI}. Cette liaison utilise 3 ou 4 conducteurs. Ils sont appelés SLCK (\textsf{Serial Clock}), MISO (\textsf{Master Input Slave Output}), MOSI (\textsf{Master Output Slave Input})  et SS (\textsf{Slave Select}). Le dernier n'étant utile uniquement si il y a plusieurs \textit{slave} dans le système. Dans notre cas, le \pic est \textit{master} et le \dspic est \textit{slave}.
				
				\setlength{\unitlength}{1mm}
\begin{figure}
	\begin{picture}(210,45)
	
		\multiput(15,20)(50,0){4}{\oval(30,10)}
		\put(115,40){\oval(30,10)}
		\put(115,25){\line(0,1){10}}	  
		\put(165,0){\oval(30,10)}	 
		\put(165,5){\line(0,1){10}}   
		\multiput(30,20)(50,0){3}{\line(1,0){20}}  
		
	    \put(3,19){Smartphone}
	    \put(59,19){HC-05}
	    \put(105,19){\pic}
	    \put(102,39){Servomoteur}
	    \put(152,19){\dspic}
	    \put(155,-1){Onduleur}
	    
	    \scriptsize
	    \put(34,16){Bluetooth}
	    \put(88,16){Série}
	    \put(140,16){SPI}
	    \put(36,22){<0-255>}
	    \put(85,22){<0-255>}
	    \put(135,22){<100-200>}
	    \put(117,29){PWM}
	    \put(167,9){PWM}
	\end{picture}
	\caption{Diagramme de communication}
	\label{com}
\end{figure}
				\subsubsection{Protocole}
				Avant de mettre en place une communication, il faut définir le \textit{langage} dans le quel nous allons parler. Entre le Smartphone et le Module Bluetooth, nous envoyons un octet. Nous avons donc 256 valeurs pour échanger les informations de puissance, de direction et d'effets. Nous avons donc décidé qu'à chaque mise à jour des curseurs de contrôle, des boutons d'effet ou en cas d'overflow du timer de sécurité, un nombre entre 0 et 255 serait envoyé par Bluetooth. On peut donc résumer les différentes significations dans le tableau \ref{protocol}.
\begin{table}[h]
	\begin{center}
	
	\begin{tabular}{cc}
		<0>       & Information de connexion \\
		<1>    	  & Non utilisé               \\
		<2-20>    & Contrôle de la direction  \\
		<21-94>   & Non utilisé               \\
		<95-200> & Contrôle de la puissance  \\
		<201-255> & Effets                   
	\end{tabular}
		\end{center}
	\caption{Correspondance entre les valeurs et les fonctions associées}
	\label{protocol}
\end{table}

			\subsection{Application}
			Afin de pouvoir utiliser notre propre protocole, défini ci dessous et d'avoir notre propre interface graphique, nous avons décider de créer notre application de A à N. Pour cela, nous avons utilisé l'outil développé par le MIT, \href{http://ai2.appinventor.mit.edu/}{ MIT App Inventor}. Cette outils en ligne permet de créer avec des blocs de simples applications pour smartphone.
		\paragraph{Interface de connexion} Lorsque nous démarrons l'application, nous arrivons sur un écran (figure \ref{Connec}) qui scan et liste les différents périphériques \textit{Bluetooth Low Energy} à proximité de notre smartphone. Cette vue reprend les éléments développés dans ce tutoriel \cite{tutoBLE} du MIT. Plusieurs options s'offrent à nous, le scan des périphériques alentours ou la connexion à un des périphériques. Lorsque nous nous connectons à un périphérique, nous basculons sur l'écran de commande de l'Aéroglisseur.
		\begin{figure}
			\begin{center}
				\includegraphics[width=0.3\textwidth]{../Illus/AppConnection.png}
			\end{center}
			\caption{Écran de connexion au périphérique Bluetooth}
			\label{Connec}
		\end{figure}
			\paragraph{Interface de commande} L'écran de commande (figure \ref{Pilo}) est composé de deux curseurs, celui de droite contrôlant la puissance et celui de gauche contrôlant la direction. En haut au milieu, il y a un bouton pour se déconnecter et revenir à l'écran d'accueil. En bas de l'écran, une série d'interrupteur permettant l'allumage de différents effets.
			\begin{figure}
		\begin{center}
			\includegraphics[width=0.6\textwidth]{../Illus/AppPilotage.png}
		\end{center}
			\caption{Écran de pilotage de l'aéroglisseur}
			\label{Pilo}
		\end{figure}
		\paragraph{Programmation}
		La programmation sur MIT App Inventor s'effectue avec des blocs. Chaque élément ajouté sur un écran est associé à des blocs fonctionnels. Cette manière de fonctionner ne permet pas de réaliser des applications extrêmement complexes mais permet de réaliser rapidement des interfaces sur smartphone. Notre application ne nécessite pas énormément de choses pour fonctionner, les écrans sont très simples. Nous pouvons résumer le fonctionnement de l'application avec le diagramme \ref{algoApp}.
		\begin{figure}
		\begin{picture}(230,115)
		\scriptsize
			\put(10,50){\framebox(25,10)[c]{\shortstack{Mouvement du\\ curseur Direction}}}
			\put(45,50){\framebox(25,10)[c]{\shortstack{Mouvement du\\ curseur Puissance}}}
			\put(80,50){\framebox(25,10)[c]{Appui sur un effet}}
			\put(115,50){\framebox(25,10)[c]{Fin du timer}}
			\put(150,50){\framebox(25,10)[c]{\shortstack{Appui sur\\ déconnexion}}}

			\put(92.5,80){\line(0,-1){10}}
			\put(22.5,70){\line(1,0){140}}			
		
			\multiput(22.5,50)(35,0){4}{\vector(0,-1){20}}
			\multiput(22.5,20)(35,0){4}{\vector(0,-1){10}}
			\multiput(22.5,70)(35,0){5}{\vector(0,-1){10}}
			\put(162.5,50){\line(0,-1){20}}			
			
			\put(162.5,30){\line(1,0){20}}
			\put(182.5,30){\line(0,1){90}}
			\put(0,10){\line(1,0){127.5}}			
			
			\put(0,75){\vector(1,0){92.5}}			
			
			\put(0,10){\line(0,1){65}}				
			
			\put(10,20){\framebox(25,10)[c]{\shortstack{Envoi de la valeur\\<2-20>}}}
			\put(45,20){\framebox(25,10)[c]{\shortstack{Envoi de la valeur\\<95-200>}}}
			\put(80,20){\framebox(25,10)[c]{\shortstack{Envoi de la valeur\\<201-255>}}}
			\put(115,20){\framebox(25,10)[c]{\shortstack{Envoi de la valeur\\<0>}}}

			
			\put(80,80){\framebox(25,10)[c]{\shortstack{Appui sur\\ connexion}}}
			
			\put(80,100){\framebox(25,10)[c]{\shortstack{Scan}}}
			\put(92.5,100){\vector(0,-1){10}}
			\put(92.5,120){\vector(0,-1){10}}
			\put(110,95){\line(0,1){20}}
			\put(92.5,95){\line(1,0){17.5}}
			\put(92.5,120){\line(1,0){90}}
			\put(92.5,115){\line(1,0){17.5}}
		\end{picture}
			\caption{Algorithme de fonctionnement de l'application}
			\label{algoApp}
		\end{figure}
		\\Chaque fonction ci dessus est assimilable à un bloc de MIT App Inventor. Par exemple, prenons la branche \textit{Mouvement curseur direction}.
		\begin{figure}
			\begin{center}		
				\includegraphics[width=0.5\textwidth]{../Illus/MITBlock.png}
				\includegraphics[width=0.2\textwidth]{../Illus/MITScreen.png}
			\end{center}
			\caption{Vues de MIT App Inventor}
		\end{figure}
		Nous pouvons voir les différents éléments constituant notre application, et un exemple de bloc qui réagit aux changements de position du curseur pour l'envoyer sur la liaison Bluetooth Low Energy.
		\\Les sources du projet de l'application est disponible sur notre dépôt Github ici \cite{git}.
			\subsection{Liaison Bluetooth}
			Après avoir émis les informations de pilotage, il faut les récupérer pour les exploiter. Nous avons donc mis en place une liaison série entre le module Bluetooth HC-05 et le \pic. Cette liaison est déclarée à 9600 bauds.
			\paragraph{Mise en place}La configuration du module \textit{UART} du \pic est réalisée en s'appuyant sur la documentation technique \cite{DatasheetPIC}. On décide des pins que l'on va utiliser, tous les pins utilisés sur les microcontrôleurs sont précisés dans le tableau \ref{pinoutpic}.
			
			\insertcode{../../ENUM/Codes/mainpic.c}{73-83,180-182,186-192}{Initialisation de la liaison série sur le \pic}
			
	%interuptuion mise en place lien vers partie du traitenemnt
			\subsection{Liaison SPI}
			La liaison SPI fonctionne comme un registre à décalage. Le \textit{master}, ici le \pic, échange son registre \texttt{SSP1BUF} avec le \textit{slave}, le \dspic, au rythme d'une horloge générée par le \textit{master}.
	\begin{figure}[hb]
		\begin{center}
			\begin{picture}(125,30)
			\tiny
			\multiput(0,10)(75,0){2}{
				\multiput(5,0)(5,0){8}{\framebox(5,5){}}
				\put(23,-2){\vector(1,0){8}}
			}
			
			\put(42.5,10){\line(0,-1){5}}
			\put(82.5,5){\vector(0,1){5}}
			\put(42.5,5){\line(1,0){40}}
			
			\put(7.5,20){\vector(0,-1){5}}
			\put(117.5,15){\line(0,1){5}}
			\put(7.5,20){\line(1,0){110}}
			
			\multiput(55,30)(1.5,2){2}{
				\multiput(0,0)(3,0){5}{
					\put(0,0){\line(1,0){1.5}}				
				}			
			}
			\put(49,27.5){\vector(1,0){29}}
			
			\multiput(55,30)(1.5,0){10}{
					\put(0,0){\line(0,1){2}}				
				}
			\multiput(0,0)(75,0){2}{
				\multiput(3.5,0)(45.5,0){2}{
					\multiput(0,0)(0,3){12}{\line(0,1){1.75}}			
				}
				\multiput(3.5,0)(0,35){2}{
					\multiput(0,0)(3,0){15}{\line(1,0){1.75}}			
				}
			}
			
			\put(20,32){\pic}
			\put(100,32){\dspic}
			\put(59,24.5){SCK}
			\put(59,17){MISO}
			\put(59,2.5){MOSI}
			\end{picture}
		\end{center}
		\caption{Fonctionnement du SPI}
	\end{figure}
			\subsubsection{Sur le \pic}
			\paragraph{Mise en place}La configuration du module \textit{SPI} du \pic est réalisée en s'appuyant sur la documentation technique \cite{DatasheetPIC}. On décide des pins que l'on va utiliser, tous les pins utilisés sur les microcontrôleurs sont précisés dans le tableau \ref{pinoutpic}.
			\insertcode{../../ENUM/Codes/mainpic.c}{95-107}{Initialisation de la liaison SPI sur le \pic}
			\paragraph{Utilisation} Pour envoyer la valeur souhaitée sur la liaison, on écrit dans le registre \texttt{SSP1BUFF}.
			\subsubsection{Sur le \dspic}
			\paragraph{Mise en place}La configuration du module \textit{SPI} du \dspic est réalisée en s'appuyant sur les documentations techniques \cite{DatasheetDSPIC} et \cite{DatasheetDSPIC30} . On décide des pins que l'on va utiliser, tous les pins utilisés sur les microcontrôleurs sont précisés dans le tableau \ref{pinoutdspic}.
			\insertcode{../../ENUM/Codes/maindspic.c}{133-147}{Initialisation de la liaison SPI sur le \dspic}
			\paragraph{Utilisation} On ne souhaite pas envoyer de message depuis le \dspic. On se contente donc de réceptionner la donnée avec un interruption puis de la traiter.
		\section{Fonctionnement}
		Dans les tableaux \ref{pinoutdspic} et \ref{pinoutpic} sont réunis tous les pins utilisés sur chacun de nos microcontrôleurs. Cette répartition n'a pas forcément de logique et s'appuie principalement sur les éléments contenus dans les datasheets ou sur des exemples trouvés sur internet.\\
		\begin{table}[h]
			\begin{multicols}{2}
			\begin{center}
			
			
			\begin{footnotesize}
			\begin{tabular}{r|ccc|l}
				VCC		& 1 &   & 20 & GND \\ 
				  		& 2 &   & 19 & PRGD \\ 
				Effet	& 3 &   & 18 & PRGC \\ 
				MCLR 	& 4 &   & 17 & Arrêt d'urgence \\ 
				Servo 	& 5 &   & 16 &   \\
				 Effet	& 6 &   & 15 &   \\ 
				(Enable)	& 7 &   & 14 & SDO \\ 
				UVFB 	& 8 &   & 13 & SDI \\ 
				BTTX 	& 9 &   & 12 & BTRX \\ 
				SCK 	& 10&   & 11 & Effet   \\ 
				\end{tabular} 
				\\ \texttt{Enable} non utilisé, il permet d'éteindre l'alim
			\end{footnotesize}
				
			
			\caption{Plan de branchement sur le \pic}
			\label{pinoutpic}
		
			
			\begin{footnotesize}
				\begin{tabular}{r|ccc|l}
				MCLR 	& 1 &    & 28 & AVDD 	\\ 
				LED  	& 2 &    & 27 & AVSS 	\\ 
				  		& 3 &    & 26 & PWM1L	\\
				  		& 4 &    & 25 & PWM1H	\\ 
				  		& 5 &    & 24 & PWM2L	\\ 
				  		& 6 &    & 23 & PWM2H  	\\ 
				 		& 7 &    & 22 & PWM3L  	\\ 
				GND 	& 8 &    & 21 & PWM3H  	\\ 
				  		& 9 &    & 20 & VDD 	\\ 
				  		& 10 &   & 19 & GND 	\\ 
				  		& 11 &   & 18 & SDI 	\\ 
				  		& 12 &   & 17 & SDO 	\\ 
				VDD 	& 13 &   & 16 & SCK 	\\ 
				  		& 14 &   & 15 & Zero Cross\\ 
				\end{tabular} 
			\end{footnotesize}
			\caption{Plan de branchement sur le \dspic}
			\label{pinoutdspic}
			\end{center}
			\end{multicols}
		\end{table}

		\begin{figure}[!h]
			\begin{picture}(210,85)
			\tiny
			
			\newsavebox{\diamo}
				\savebox{\diamo}
				  (20,15){% definition
				  \put(-10,0){\line(5,2){10}}
				  \put(-10,0){\line(5,-2){10}}
				  \put(10,0){\line(-5,2){10}}
				  \put(10,0){\line(-5,-2){10}}
				}
				
				%centre
				\put(90,85){\oval(20,8)}
				\put(86.5,84){Début}
				
				\put(90,81){\vector(0,-1){5}}
				\put(80,68){\framebox(20,8)[c]{\shortstack{Initialisation\\(PWM,Timer,Com)}}}
				
				\put(90,68){\line(0,-1){15}}
				%droite
				\put(50,53){\line(1,0){120}}	
						
				\multiput(110,53)(30,0){3}{\vector(0,-1){4.75}}			
				\multiput(110,37)(30,0){3}{\usebox{\diamo}}
				\multiput(110,40.75)(30,0){3}{\vector(0,-1){4.75}}
				\multiput(100,27.75)(30,0){3}{\framebox(20,8)[c]{}}
				\multiput(110,27.75)(30,0){3}{\line(0,-1){7.75}}
	
				\put(185,60){\vector(-1,0){95}}
				\put(185,60){\line(0,-1){50}}
				
				\put(110,20){\line(1,0){60}}
				\put(140,20){\line(0,-1){10}}
				\put(140,10){\line(1,0){45}}
	
				\put(11,43){\line(1,0){66}}	
				\put(50,53){\line(0,-1){10}}		
				
				%gauche
				\multiput(11,43)(22,0){3}{\vector(0,-1){4.75}}			
				\multiput(11,27)(22,0){3}{\usebox{\diamo}}
				\put(77,43){\vector(0,-1){16.25}}
				\multiput(11,30.75)(22,0){3}{\vector(0,-1){4.75}}
				\multiput(1,17.75)(22,0){4}{\framebox(20,8)[c]{}}
				\multiput(11,17.75)(22,0){4}{\line(0,-1){7.75}}
				
				\put(11,10){\line(1,0){66}}		
				\put(0,0){\line(1,0){50}}			
				\put(0,0){\line(0,1){65}}	
				\put(0,65){\vector(1,0){90}}			
				\put(50,10){\line(0,-1){10}}
				
				
				%cadre
				\multiput(95,49)(87,0){2}{
					\multiput(0,0)(0,-3){9}{\line(0,-1){1.5}}			
				}
				\multiput(95,49)(0,-27){2}{
					\multiput(0,0)(3,0){29}{\line(1,0){1.5}}			
				}
				%texte
	
				\put(46,33.5){\shortstack{Mode\\Arrêt d'Urgence?}}
				\put(6,33.5){\shortstack{Mode\\Défaut BT?}}
				\put(29,33){\shortstack{Batterie\\ Faible?}}
				\put(50,18.5){\shortstack{Effet 1\\Puissance 0\\Servo droit}}
				\put(28,18.5){\shortstack{Effet 2\\Puissance 0\\Servo droit}}
				\put(6,18.5){\shortstack{Effet 3\\Puissance 0\\Servo droit}}
				\put(70,18){\shortstack{Mise à jour Effet\\Envoi Puissance\\Mise à jour Servo}}
				
				\put(102,44){\shortstack{Arrêt d'Urgence}}
				\put(135.5,42){\shortstack{Réception\\BT}}
				\put(165.5,42.25){\shortstack{Timer\\overflow}}
				\put(102,30){\shortstack{Activer Mode\\Arrêt d'urgence}}
				\put(130.5,30){\shortstack{Décodage \\Mise à Jour des états}}
				\put(163,30){\shortstack{Activer Mode\\Défaut BT}}
				
				\put(96,25){Interruptions}
			\end{picture}
			\caption{Algorithme simplifié du code du \pic}
			\label{algoPic}
		\end{figure}
			\paragraph{Sur le \pic} Le déroulement du programme sur le \pic suit le schéma représenté sur le diagramme \ref{algoPic}. On peut y voir une phase d'initialisation, configurant les différents registres dont on a besoin. La boucle principale, représentée sur la gauche de l'algorithme, se charge de l'affichage et de la mise à jour de tous les processus. \textit{(Position du servomoteur, Puissance de la propulsion au travers du \dspic, gestion des \textbf{effets non pyrotechnique}} \emph{(les effets pyrotechniques étant interdits dans le cahier des charges)}). Cette boucle est interrompue par les fonctions \textit{d'interruptions} gérant l'arrivée de nouvelles informations ou de défauts, ces fonctions sont représentées à droite de l'algorithme. Le contenu ainsi que le fonctionnement des fonctions est détaillé fonction par fonction dans les paragraphes suivants.
			%\paragraph{Sur le \dspic}
			\subsection{Contrôle du servomoteur}
				\paragraph{Fonctionnement}
			Un servomoteur est un moteur asservi en position ou en vitesse. Grâce à un signal de commande caractérisé plus loin, le moteur rejoint une position angulaire ou une vitesse donnée. L'emploi de ce type d'actionneur est simple, une alimentation fixe en 0-5V et un signal de commande permet la réalisation simple de système contrôlé angulairement. Le mot \textit{"servo"} ne vient pas de cerveau qui signifierait intelligent mais du latin \emph{servus} qui signifie esclave. Il s'agit donc d'un moteur esclave, plus précisément un moteur asservi.
			
				\paragraph{Commande}Le signal de commande employé pour contrôler les servomoteurs est un signal de type PWM (Power Width Modulation, Modulation à Largeur d'Impulsion). La largeur de l'impulsion correspond à une position donnée. Le signal est un signal électrique de période 20ms, toutes les 20ms, le moteur doit recevoir un signal de commande pour s'aligner correctement. La largeur de l'impulsion varie généralement entre 0.5 et 3ms. La largeur d'impulsion fait varier proportionnellement l'angle de sortie ou la vitesse. Par exemple, si une impulsion de 0.75ms correspond à un angle de $0^{\circ}$ et une impulsion de 2.25 à un angle de $180^{\circ}$. Pour obtenir un angle de $66^{\circ}$, il faut une impulsion de 1.3ms.  
			
				\paragraph{Création du signal de commande} Afin de générer le signal de commande pour le servomoteur, nous allons utiliser le \pic. Ce composant programmable nous permettra de générer le signal comportant une impulsion de largeur variable toutes les 20ms. En jouant sur le rapport cyclique, nous jouons sur la largeur de l'impulsion. Cette largeur d'impulsion sera contrôlée par les informations reçues sur la liaison \textit{Bluetooth}. Dans la datasheet du \pic \cite{DatasheetPIC}, on peut voir la formule suivante sur la période du PWM.
				$$ PWM_{period}=(PR2+1)\times 4 \times T_{osc} \times TMR2_{prescaler}$$
				$$ 20*10^{-3}=(PR2+1) \times 4 \times \frac{1}{4*10^{6}} \times 128$$
				$$ PR2=\left(\frac{20*10^{-3}}{128*10^{-6}} \right)-1=155.25$$
				On choisit donc une valeur de \texttt{PR2} de 155. Maintenant, il nous reste à déterminer les valeurs pour obtenir des impulsions de la bonne largeur.
				$$ PulseWidth=[PWM3DCH:PWM3DCL<7-6>]\times T_{osc} \times TMR2_{prescaler}$$
				$$ PulseWidth_{min}=0.25*10^{-3}=[PWM3DCH:PWM3DCL<7-6>]\times \frac{1}{4*40^{6}} \times 128$$
				$$ PulseWidth_{max}=2.5*10^{-3}=[PWM3DCH:PWM3DCL<7-6>]\times \frac{1}{4*40^{6}} \times 128$$
				En faisant des essais sur le servomoteur, on détermine expérimentalement les valeurs montrées dans le tableau \ref{PWMval}.
				\begin{table}[h]
				\begin{center}
					\begin{tabular}{c|c|c}
					
					Angle du servo & Valeur de \texttt{PWM3DCH:PWMDCL} & Largeur de l'impulsion \\ 
					\hline 
					$0^{\circ}$ & 8 & 0.256ms \\
					$90^{\circ}$ & 40 & 1.28ms \\
					$180^{\circ}$ & 80 & 2.56ms \\ 
					
					\end{tabular} 
					\caption{Valeurs de la PWM}
					\label{PWMval}
				\end{center}
				\end{table}
				Dans notre code nous n'utilisons pas le registre \texttt{PWM3DCL}, on se contente de charger une valeur entre 2 et 20 dans le registre \texttt{PWM3DCH}, on perd en précision mais cela ne pose pas de soucis. Nous arrivons tout de même à avoir suffisamment de niveau pour remplir le cahier des charges.
				\begin{tcolorbox}[center,width=0.9\textwidth, colframe=red!90!orange, colback=orange!25, arc=3mm,boxrule=1mm, sharp corners=east,title=Note]
			L'aéroglisseur n'ayant pas pu être réalisé, les valeurs maximum et minimum sont l'amplitude maximum du servo, celui ci balaie donc les 180$^\circ$ de sa course. Dans le système réel il aurait fallu les limiter afin que la dérive ne rentre pas en butée contre la structure de l'aéroglisseur. Voir figure \ref{vues}.\\
			Si il faut réduire l'amplitude de battement du servo, il est possible que l'on ai plus assez de niveaux en utilisant uniquement le registre \texttt{PWM3DCH} et il aurait fallut utiliser l'intégralité des registres.
  			\end{tcolorbox}
			
			\subsection{Contrôle des effets}
			Afin d'ajouter un peu de beauté sur notre projet, nous avons décidé d'y ajouter quelques LEDs, c'est ce que nous appelons "effet". Contrôlé par l'application, à chaque réception du caractère associé à l'effet on "inverse" l'état de l'effet.
			\insertcode{../../ENUM/Codes/mainpic.c}{130-142}{Contrôle des effets sur le \pic}
			\begin{tcolorbox}[center,width=0.9\textwidth, colframe=red!90!orange, colback=orange!25, arc=3mm,boxrule=1mm, sharp corners=east,title=Note]
			Les effets définis dans le code ne sont pas forcément les effets définitifs, ils sont ainsi car je n'avais pas plus de LEDs à disposition.
  			\end{tcolorbox}
			
			\subsection{Sécurité}\label{secu}
			Notre projet pouvant s'avérer devenir un objet glissant incontrôlé, il faut mettre en place différents organes de sécurité.
			
				\subsubsection{Batterie faible}
				Comme décrit précédemment (voir paragraphe \ref{UVBF}) une batterie de type Li-Po ne doit pas se décharger en dessous d'un certain seuil. Le circuit décrit permet de détecter le passage sous ce seuil, mais encore faut-il faire quelque chose. Lorsque le signal en provenance du circuit de protection de sous tensions est à l'état bas, nous empêchons toutes communications et nous déclenchons un effet visuel pour avertir l'utilisateur.
				\insertcode{../../ENUM/Codes/mainpic.c}{226-231}{Gestion de la sous tension batterie sur le \pic}
				\subsubsection{Perte de connexion}
				La perte de connexion entre l'Aéroglisseur est le Smartphone peut être un problème dangereux, personne n'a envie de se confronter à un aéroglisseur fou avec une hélice tranchante en rotation. Pour éviter ce soucis, l'application Bluetooth envoie au minimum un caractère toutes les 100ms, voir paragraphe \ref{algoApp}, soit par une action de l'utilisateur, l'information est envoyée, soit en cas d'overflow d'un timer sur l'application, ce timer déclenche l'envoi d'un 0 toutes les 100ms. À chaque réception d'un nouveau caractère, un timer sur le \pic est réinitialisé. Si le timer déclaré sur le \pic overflow, une interruption est déclenchée, elle met la valeur de la puissance à 0, le servomoteur de direction droit et allume un effet visuel.
				\insertcode{../../ENUM/Codes/mainpic.c}{84-94,113-115,143-146}{Gestion de la perte de connexion sur le \pic}
				
				\subsubsection{Arrêt d'urgence}\label{AU}
				Un arrêt d'urgence, sous la forme d'un \textbf{gros bouton rouge}, n'est pas envisageable pour notre système, car encore une fois devoir d'approcher d'un aéroglisseur fou n'est pas une partie de plaisir. Nous avons donc pensé à une corde qui \textit{pend} à l'arrière de l'engin. En tirant sur cette corde, on active un système de bouton qui permet de mettre l'aéroglisseur en un mode de sécurité. Un jumper présent sur la carte permet de servir de commutateur. Sur un front descendant, nous déclenchons une interruption semblable à celle définie ci dessus pour la perte de connexion.
				
				\insertcode{../../ENUM/Codes/mainpic.c}{152-156}{Gestion de l'arrêt d'urgence sur le \pic}
				
				\subsubsection{Hiérarchisation des "erreurs"}
				Le traitement des erreurs a lieu en plusieurs phases. Il y a la phase de détection qui peut avoir lieu avec des interruptions ou pas. Les erreurs sont donc hiérarchisée comme dans le tableau \ref{hierar}.\\
				\begin{table}[hb]
				\begin{center}
					\begin{tabular}{r|l}
					Priorité&Type d'erreur\\
					\hline
					 1 & Arrêt d'urgence 	\\ 
					 2 & Sous tension batterie 	\\ 
					 3 & Perte de connexion Bluetooth	\\
					 4 & Fonctionnement normal	\\
					\end{tabular} 
					\caption{Hiérarchisation des erreurs dans le code}
					\label{hierar}
					\end{center}
				\end{table}
				Nous traitons en premier lieu le \texttt{global fail} lié à l'arrêt d'urgence, puis la sous tension, la perte de connexion et enfin le fonctionnement sans erreur. Cette hiérarchisation ne pose pas de problèmes étant donné que les différences de traitement résident principalement dans la nature de l'effet avertissant l'utilisateur
			\subsection{Contrôle à partir des données Bluetooth}
			Maintenant que chaque fonctionnalité a été présentée, nous pouvons tout réunir. Le fonctionnement global de notre code s'articule autour de deux parties de code: l'interruption déclenchée par l'arrivée d'informations sur le module Bluetooth et la boucle principale.
			\paragraph{Réception Bluetooth} La réception d'information provenant du module Bluetooth sur la liaison série déclenche une interruption. Lorsque cela arrive, le programme en cours est \textit{immédiatement} stoppé et exécute le contenu de la routine associée. Dans notre cas, la routine associée permet de récupérer la valeur reçue, cette valeur est \textit{décodée} en suivant le protocole défini précédemment, paragraphe \ref{protocol}.
			\begin{itemize}
			\item[$\bullet$] Si la valeur reçue correspond à une mise à jour des effets, les variables \texttt{eff1} et \texttt{eff2} sont mises à jour, ici complémentée. 
			\item[$\bullet$] Si la valeur reçue correspond à une mise à jour de la direction, on met à jour la variable \texttt{ang}, qui représente la valeur à mettre dans le registre de gestion de la PWM. En effet, pour cette action, il n'y a aucun traitement à faire, c'est pour cela que les valeurs sont ainsi sur le curseur de l'application.
			\item[$\bullet$] Si la valeur reçue correspond à une mise à jour de la puissance de propulsion, un traitement est effectué avant d'être envoyé dans la variable \texttt{puissance} qui sera envoyée sur le \textit{SPI}. On réajuste les valeurs reçues afin qu'elles correspondent par la suite à la valeur nécessaire pour contrôler les signaux PWM contrôlant l'onduleur. On effectue donc une transformation linéaire pour passer d'une valeur entre 95 et 200 à une valeur entre 0 et 230.
			$$ x\in [95;200];y\in [0;230] \Rightarrow y=2.19*x-208 $$
			\label{picmain}
			\item[$\bullet$] Si la valeur ne correspond à rien ou est un 0, le message sert juste à montrer que l'application est toujours connectée pour des raisons de sécurité, comme expliqué au paragraphe \ref{secu}.		
			\end{itemize}			 
			\insertcode{../../ENUM/Codes/mainpic.c}{111-142}{Réception Bluetooth sur le \pic}
			\paragraph{Boucle principale} Dans la boucle, on retrouve la gestion des modes. Notre système comporte quatre "modes":
			\begin{itemize}
			\item[$\bullet$] Le mode normal (\texttt{fail=0 et gfail=0}), il s'agit du mode par défaut et normal du système. Dans ce cas, la consigne en puissance est transmise au \dspic, la PWM contrôlant le servo et les effets sont mis à jour toutes les 10ms.
			\item[$\bullet$] Le mode défaut (\texttt{fail=1 et gfail=0}), il s'agit du mode "sans connexion". Il n'y a aucune information qui est arrivée sur la liaison Bluetooth depuis trop longtemps. On met l'aéroglisseur en sécurité, la consigne de puissance est nulle et la dérive est dans une position droite et on fait clignoter un effet afin d'avertir l'utilisateur. Dès que la connexion Bluetooth est rétablie, le système peut repasser en mode normal. Un exemple de cette situation pourrait être que l'aéroglisseur est trop loin du pilote ou encore que le pilote a fermé l'application. Dans ce cas, l'aéroglisseur s'arrête automatiquement.
			\item[$\bullet$] Le mode sous tension de batterie (signal à l'état bas sur \texttt{RC3}). On met l'aéroglisseur en position de sécurité et on avertit l'utilisateur, la batterie doit être rechargée.
			\item[$\bullet$] Le mode défaut global (\texttt{fail=1 et gfail=1}), ce mode n'est activé que lorsque l'arrêt d'urgence a été activé, lorsque l'on a arraché le jumper de sécurité. On met l'aéroglisseur en sécurité, la consigne de puissance est nulle et la dérive est dans une position droite et on fait clignoter tous les effets afin d'avertir l'utilisateur qu'il s'agit d'un autre défaut que ci dessus. En revanche dans ce mode, le redémarrage est impossible. Il faut débrancher la batterie, remettre en place le jumper de sécurité et réalimenter le système. Dans ce mode, toutes nouvelles informations sont bloquées, plus aucun événement ne peut déclencher une interruption. 
			\end{itemize}
			\insertcode{../../ENUM/Codes/mainpic.c}{216-247}{Boucle principale du \pic}
			
			
			\subsection{Contrôle de l'onduleur}			
			\begin{tcolorbox}[center,width=0.9\textwidth, colframe=red!90!orange, colback=orange!25, arc=3mm,boxrule=1mm, sharp corners=east,title=Note]
			Cette partie a été réalisée durant la période de fermeture de l'école. N'ayant pas eut un oscilloscope et un moteur brushless à disposition, les codes n'ont pas été testé sur système réel. Le projet a été simulé sur \textit{MPLABxIDE}. Malheureusement, ce simulateur présente de nombreux défauts comme un manque de stabilité et des visualisations de sortie très limitées, notamment sur la durée des simulations. Les valeurs calculées ne sont donc pas forcément adaptées\\
  			Comme vous pourrez le voir dans la partie \ref{real}, un système de LED est ajouté pour visualiser les sorties PWM. 
  			\\De plus, le système de Back EMF n'est pas réellement implémenté.
  			\end{tcolorbox}
  			Le contrôle de l'onduleur, présenté paragraphe \ref{onduleur}, est effectué par le \dspic . Il s'agit donc de créer 6 signaux  PWM pour contrôler chaque transistor de la structure globale. De plus, ces signaux doivent être cadencés afin de créer un champ tournant mais aussi synchroniser avec la méthode de \textit{Back EMF}.
  			\paragraph{Mise en place des signaux PWM}
  			La mise en place des signaux PWM sur le \dspic a été effectuée en suivant le tutoriel \cite{PWMds}. On obtient 6 signaux PWM. Les signaux sont liés 2 à 2, il y a un signal PWM et son complément. On a donc PWMxL et PWMxH pour chaque sortie 1, 2 et 3. On retrouve cette répartition sur la figure \ref{imgPWM}.\\
  			\begin{figure}[h]\begin{center}
	  			\includegraphics[width=0.8\textwidth]{../Illus/pwm100.png}
	  			\caption{Simulation des signaux PWM}
	  			\label{imgPWM}
	  			\end{center}
  			\end{figure}
  			L'onduleur doit être piloté avec des signaux de commandes d'une fréquence entre 16kHz et 20kHz. Aidons nous de la datasheet \cite{DatasheetDSPIC} pour calculer la fréquence de notre PWM. Nous avons notre générateur de PWM configuré en \textit{Free Running Mode}, on utilise donc la formule suivante:
  			$$T_{PWM}=\frac{1}{F_{PWM}}=T_{CY}\times (PTPER+1)\times PTMR_{Prescaler}$$
  			$$\frac{1}{16*10^{3}}=\frac{4}{7.37*10^6}\times (PTPER+1)\times 1$$
  			$$PTPER=\frac{7.37*10^6}{4 \times 16*10^3}-1=114.15625 $$ 
  			\insertcode{../../ENUM/Codes/maindspic.c}{78-101}{Mise en place des signaux PWM sur le \dspic}
  			On peut maintenant calculer la résolution du PWM afin de savoir quel consigne devons nous lui donner. On utilise donc la formule de la datasheet:
  			$$\frac{\log\left(2 \times \frac{F_{CY}}{F_{PWM}}\right)}{\log 2}=7.84$$
  			On peut donc commander le signal PWM entre 0 et $2^{7.84}$ soit 230.
			\paragraph{Contrôle depuis les informations du \pic}
			Les informations en provenance du \pic sont entre 0 et 230. Elles sont mises en forme sur le \pic, voir paragraphe \ref{picmain}. En revanche, on n'utilise pas la plage à 100\%, en effet, une bande morte est présente entre les valeurs 0 et 10 afin d'avoir une bande où la fréquence de rotation est faible afin que le moteur accroche.
			\paragraph{Relation entre PWM et pulsation}
			%Voir si c'est ici ou dans la partie du BLDC	
			Le BLDCM est un moteur synchrone, le champs tourne à la même vitesse et avec un déphasage constant avec le rotor de la machine. Pour faire varier la vitesse du moteur, nous devons faire varier la pulsation électrique. Or si le moteur accélère, lorsque la fréquence augmente, il a besoin de plus de puissance, la valeur efficace des tensions d'alimentation doit augmenter, donc la valeur du rapport cyclique du PWM. La relation liant la pulsation et la valeur efficace est donnée par.
			$$V=K_v \omega_meca$$
			Dans la datasheet du moteur \cite{moteur}, on peut voir un coefficient de 1100 donné en Tours par Minute par Volt.
			Pour tourner à 1100rpm, il a besoin de 1V. La batterie permet de délivrer une tension nominale 11.1V, paragraphe \ref{batterie}. Le moteur tournera donc à 12 210 tours par minute. On peut convertir ça en tours par seconde, soit en Hertz. La fréquence de rotation mécanique est donc de 203.5 Hz pour 11.1V et 18.333 Hz pour 1V.\\
			Le moteur dispose de 5 paires de pôles, on a donc une fréquence électrique 5 fois supérieure à la fréquence mécanique.
			Nous devons configurer le timer qui compte ni trop vite ni trop lentement afin d'avoir un bon contrôle sur la précision du système.\\
			\begin{table}[h]
						\centering
			\begin{tabular}{|c|c|c|c|}
			PWM <0-230> & U (V) & $F_{elec}$ & $F_{meca}$ \\ 
			\hline 
			0 & 0V & 0 Hz & 0 tr/s \\ 
			20 & 0.965V &  88.48 Hz & 17.69 tr/s \\ 
			50 & 2.41V &  221.19 Hz & 44.2 tr/s \\ 
			115 & 5.55V & 508.75 Hz & 101.75 tr/s \\ 
			230 & 11.1V & 1017.5 Hz & 203.5 tr/s \\ 
			\end{tabular} 
			\caption{Valeur de PWM, de fréquences et de Tension aux bornes du moteur}
			\label{freqPWMVitesse}
			\end{table}
			Nous avons décidé de prendre un timer qui compte sur la fréquence instruction divisé par 8. On obtient donc le tableau \ref{per} en reprenant les éléments du tableau \ref{freqPWMVitesse}. On obtient une période d'une incrémentation du timer de $\frac{8*4}{7.37*10^6}=4.3419 \mu s $ \\
			\begin{table}[h]
			\centering
			\begin{center}
			\begin{tabular}{|c|c|c|c|c|}
			PWM <0-230> & U (V) & $F_{elec}$ & Période & Valeur timer \\ 
			\hline 
			0 & 0V & 0 Hz & $+\infty$ &  [65 535]\\ 
			20 & 0.965V &  88.45 Hz & 11.306 ms & 2604\\ 
			50 & 2.41V &  221.19 Hz & 4.521 ms & 1041\\ 
			115 & 5.55V & 508.75 Hz & 1.9656 ms & 452\\ 
			230 & 11.1V & 1017.5 Hz & 0.9828 ms & 226\\ 
			\end{tabular} 
			\end{center}
			\caption{Valeur de PWM, de fréquences et de Tension aux bornes du moteur}
			\label{per}
			\end{table}
			On peut maintenant trouver une relation entre les valeurs de PWM et la valeur du timer. La relation est inversement proportionnelle. 
			$$CMD_{Onduleur}=\frac{54600}{PWM}$$\\
			\begin{figure}[!h]
			\centering
				\begin{tikzpicture}
					\begin{axis}[width=0.9\textwidth,height=0.502\textwidth,xmin = 0, xmax = 240, ymin = 0, ymax = 75000, xlabel = PWM, ylabel = {Timer},title={Relation entre la valeur du Timer et la valeur de la PWM}]
					\addplot[domain = 0:230,samples = 460,legend pos=north west] {54600/x};
					\addlegendentry{$\frac{54600}{PWM}$}
					\addplot[domain = 10:230,samples = 460,legend pos=north west, color=red] {54600/x};
					\addplot[domain = 0:10,samples = 2,legend pos=north west, color=red] {65535};
					\addplot[color=red]coordinates {(10,65535) (10,5460)};
					\addlegendentry{$Cmd^{reel}_{Onduleur}$}
					\end{axis}
				\end{tikzpicture}
				\caption{Relation entre la valeur du Timer et la Valeur de la PWM}
			\end{figure}		
			\newpage
			Dans un second temps, afin de limiter les risques de décrochage, les variations de fréquence et de rapport cyclique se font sous la forme d'une rampe. On compare toutes les 40ms la valeurs de la puissance actuelle à la valeur de la consigne souhaitée. On incrémente ou décrémente la valeur actuelle pour converger vers la valeur souhaitée. Ainsi les accélérations et décélérations du champs tournant sont plus facilement suivies le rotor.
			 \begin{tcolorbox}[center,width=0.9\textwidth, colframe=red!90!orange, colback=orange!25, arc=3mm,boxrule=1mm, sharp corners=east,title=Note]
			La pente de cette rampe a été définie à 40ms afin d'avoir un effet visuel ni trop rapide ni trop lent lors des tests montrés partie \ref{real}. Cette valeur serait à ajuster sur le système réelle pour avoir un système le plus réactif possible sans avoir de décrochages involontaires.
  			\end{tcolorbox}
  			\paragraph{Séquençage}
  			Afin de générer un champs tournant, on doit alterner l'activation et la désactivation des différentes sorties actives à l'état haut ou à l'état bas. La séquence utilisée est décrite dans la note d'application \cite{AN857}. Afin de générer le changement de secteur, on utilise un second timer dont la période est égale à un sixième de la période du timer défini pour le tableau \ref{per}.
  			\begin{table}[h]
			\centering
			\begin{center}
			\begin{tabular}{|c|c|c|c|}
			PWM <0-230> & Timer global & Timer Secteur &  Période secteur \\ 
			\hline 
			0 & [65 535]&[10 922]& 47 ms\\ 
			20 &  2604 &434 &1.88ms\\ 
			50 &  1041& 173&0.75ms\\ 
			115 &  452& 75&0.32ms\\ 
			230 &  226& 38&0.16ms\\ 
			\end{tabular} 
			\end{center}
			\caption{Valeur de PWM, des timer et la période par secteur}
			\end{table}
  			\insertcode{../../ENUM/Codes/maindspic.c}{102-132}{Gestion de l'ordre des phases sur le \dspic}
  			On obtient donc les signaux figure \ref{imgPWMCad}.
  			\begin{figure}[h]\begin{center}
	  			\includegraphics[width=0.9\textwidth]{../Illus/PWMCadence2015.png}
	  			\caption{Simulation des signaux PWM cadencés}\small(L'échelle de temps n'est pas correcte, afin de pouvoir observer tous les signaux sur le simulateur)
	  			\label{imgPWMCad}
	  			\end{center}
  			\end{figure}
  			Une fois les signaux dans le bon ordre, il faut les déclencher au bon moment. Pour cela, nous utilisons le principe de la \textit{Back EMF}, le système déclenche une interruption qui permet de resynchroniser la séquence des phases au secteur où est actuellement le rotor.
  			\paragraph{Fonctionnement général}
  			L'algorithme simplifié du code du \dspic est représenté figure \ref{algodsPic}. On y retrouve les phases d'initialisations, d'interruption et la boucle principale comme pour dans l'algorithme \ref{algoPic} pour le \pic . 
  			\begin{figure}[!h]
			\begin{picture}(210,85)
			\tiny				
			
			\newsavebox{\diamon}
				\savebox{\diamon}
				  (20,15){% definition
				  \put(-10,0){\line(5,2){10}}
				  \put(-10,0){\line(5,-2){10}}
				  \put(10,0){\line(-5,2){10}}
				  \put(10,0){\line(-5,-2){10}}
				}
				%centre
				\put(90,85){\oval(20,8)}
				\put(86.5,84){Début}
				
				\put(90,81){\vector(0,-1){5}}
				\put(80,68){\framebox(20,8)[c]{\shortstack{Initialisation\\(PWM,Timer,Com)}}}
				
				\put(90,68){\line(0,-1){15}}
				%droite
				\put(50,53){\line(1,0){120}}	
						
				\multiput(80,53)(30,0){4}{\vector(0,-1){4.75}}			
				\multiput(80,37)(30,0){4}{\usebox{\diamon}}
				\multiput(80,40.75)(30,0){4}{\vector(0,-1){4.75}}
				\multiput(70,27.75)(30,0){4}{\framebox(20,8)[c]{}}
				\multiput(80,27.75)(30,0){4}{\line(0,-1){7.75}}
	
				\put(185,60){\vector(-1,0){95}}
				\put(185,60){\line(0,-1){50}}
				
				\put(80,20){\line(1,0){90}}
				\put(125,20){\line(0,-1){10}}
				\put(125,10){\line(1,0){60}}
	
				\put(12,43){\line(1,0){50}}	
				\put(50,53){\line(0,-1){10}}		
				
				%gauche
				\multiput(12,43)(30,0){2}{\vector(0,-1){4.75}}			
				\multiput(12,27)(30,0){2}{\usebox{\diamon}}
				\put(62,43){\line(0,-1){33}}
				\multiput(12,30.75)(30,0){2}{\vector(0,-1){4.75}}
				\multiput(2,17.75)(30,0){2}{\framebox(20,8)[c]{}}
				\multiput(12,17.75)(30,0){2}{\line(0,-1){7.75}}
				
				\put(12,10){\line(1,0){50}}		
				\put(0,0){\line(1,0){50}}			
				\put(0,0){\line(0,1){65}}	
				\put(0,65){\vector(1,0){90}}			
				\put(50,10){\line(0,-1){10}}
				
				
				%cadre
				\multiput(65,49)(117,0){2}{
					\multiput(0,0)(0,-3){9}{\line(0,-1){1.5}}			
				}
				\multiput(65,49)(0,-26){2}{
					\multiput(0,0)(3,0){39}{\line(1,0){1.5}}			
				}
				%texte
	
				\put(35,33.25){\shortstack{power\\<PowerTarget}}
				\put(6,33.25){\shortstack{power\\>PowerTarget}}
				\put(37,20.5){\shortstack{power++}}
				\put(7,20.5){\shortstack{power- -}}
				
				\put(75,42.5){\shortstack{Front sur\\entrée}}
				\put(105,44){\shortstack{Timer 2}}
				\put(135.5,42){\shortstack{Réception\\SPI}}
				\put(166,44){\shortstack{Timer 3}}
				\put(75,30){\shortstack{Changement\\ au secteur 0}}
				\put(105,30){\shortstack{Changement \\de secteur}}
				\put(132,30){\shortstack{Mise à jour \\de powerTarget }}
				\put(163,30){\shortstack{Mise à jour de la\\ pulsation}}
				
				\put(67,24){Interruptions}
			\end{picture}
			\caption{Algorithme simplifié du code du \dspic }
			\label{algodsPic}
		\end{figure}
		
		\insertcode{../../ENUM/Codes/maindspic.c}{190-231}{Boucle principale sur le \dspic}
		
		\section{Réalisation}\label{real}
			\begin{tcolorbox}[center,width=0.9\textwidth, colframe=red!90!orange, colback=orange!25, arc=3mm,boxrule=1mm, sharp corners=east,title=Note]
			La réalisation a été faite avec les \textit{moyens du bord}. Cette section présente quelques fonctionnalités fonctionnelles sur plaquette d'essais.
  			\end{tcolorbox}
  			\begin{figure}[hb]
				\begin{center}						
				\includegraphics[width=0.5\textwidth]{../Illus/real.png}
				\begin{picture}(0,0)
				\linethickness{0.3mm}
				\textcolor{red}{
					\put(-15.5,11){\framebox(4,18)}%dsPIC
					\put(-60,23){\framebox(9,4)}%PIC
					\put(-60,41){\framebox(12,4)}%BT
				}
				\textcolor{blue}{
					\put(-29,36){\framebox(22,22)}%servo
					\put(-13,2){\framebox(3,5)}%LED
					\put(-54,28){\framebox(3,3)}%LED
					\put(-62,8){\framebox(5,9)}%Fil AU
				}
				\textcolor{green}{
					\put(-37,10){\framebox(14,14)}%PWM
					\put(-56,8){\framebox(5,9)}%Fil bat
					\put(-90,49){\framebox(25,17)}%ARDuino				
				}
				\end{picture}
			\end{center}
			\caption{Prototype de travail pour le projet}
			{\footnotesize En rouge, les microcontrôleurs et le Bluetooth. En bleu, les éléments réels qui serait tel quel sur le projet. En vert, les solutions alternatives.}
		\end{figure}
  			Nous pouvons résumer en 2 catégories les composants sur la plaquette d'essais.
  			
  			\begin{table}[hb]\begin{center}
	  			\begin{tabular}{c|c}
	  			Composants réellement présent & Composant Alternatif\\
	  			\hline
	  			\pic & PWM (jeux de LED) \\ 
	  			\dspic & Fil sous tension batterie (Fil relié au VCC ou au GND)\\
	  			 Servo &  Alimentation (Arduino) \\
	  			 Module Bluetooth &\\ 
	  			 LEDs &\\
	  			 Fil d'arrêt d'urgence &\\
	  			
	  			\end{tabular}\end{center}
  			\end{table}
 Ce montage permet de réaliser et de tester quelques fonctionnalités du projet. Une vidéo valant 10000 explications, vous pouvez consulter la vidéo de ce montage en fonctionnement ici: \url{ https://youtu.be/wEylhykiFZk}
\begin{tcolorbox}[center,width=0.9\textwidth, colframe=red!90!orange, colback=orange!25, arc=3mm,boxrule=1mm, sharp corners=east,title=Note]
			La vidéo a été réalisée avec une visualisation de la relation PWM-Période proportionnelle afin de voir au mieux les variations.
  			\end{tcolorbox}
  			%\section{Problèmes et poursuites}
  			%Même si le système est plutôt fonctionnel, nous pouvons constater certains problèmes et des améliorations à apporter. 
  			%\paragraph{Contrôle du moteur} L'implémentation de la Back EMF serait encore à faire